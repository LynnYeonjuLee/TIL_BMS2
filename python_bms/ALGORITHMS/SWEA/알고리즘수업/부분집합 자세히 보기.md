### 부분집합 자세히 보기

> 처음에 리스트가 있을때 리스트의 길이를 N으로 잡는다
>
> len(list) = N

``` py
for i in range(1<<N):   ---- 1
	for j in range(N+1):   -----2
		if i & (1<<j):  ------3
		
		list[j]  ---- 4
```



___일단 비트라는데 2진수인걸 알고있는 상태를 가정하고 진행.___



1. 1번부분이 의미하는건 전체 부분집합의 갯수래.	 그러니깐 한계치를 정해두는건데 리스트 안에 숫자가 크든 작든 우리는 그 숫자 하나를 0 또는 1로만 볼거야. 	처음에는 이렇게만 이해를 하고 2번으로 넘어감
   1. 여기서 print(i) 해보면 그냥 1,2,3,4,5,6,7 이런식으로 나오는데 (2**N개 나옴)
   2. 실제로 밑에 3번에서 인식되는건 0001 0110 0101 이런식
   3. 즉 내가 N이 7이면 0000000부터 1111111 까지 나오게 된다.



2. j는 위쪽이랑 다르게 그냥 range로 나와서 0,1,2,3 ...,N까지의 숫자가 나오지.	
   1. 여기는 print()하면 그냥 나오는게 맞음
   2. 하지만 밑에 보면 프린트하는것이 list[j]라 j번째 위치의 숫자 존재 유무에 대해서 판단하는 항목이라 생각할수있슴 . 말이 어렵나 ㅎㅎ...



3. 여기서 부터가 좀 헷갈릴수있는데, 차근차근 생각해보면, 
   1. 일단 i의 숫자는 0부터 고정되서 나옴
   2. i 가 0이면 공집합이 나옴. (왜냐하면 j의 값이 어떠한게 들어가도 맞지 않으니)
   3. 이제 i의 숫자가 1이면 0000001이 되는데
   4. 여기서부터 j가 숫자를 올려가면서 확인함.
   5. 처음 j가 0이면 0000001 
   6. i의 1 위치와 j의 1 위치가 맞음 고로 1이 출력
   7. 이런식으로 진행이 된느데 이러면 나중에 값은 list[0]번째가 나옴
   8. 만약에 i가 7 이면 0000111이 되서 j도 0,1,2가 맞는 위치라 
   9. list[0,1,2] 의 숫자가 출력이됨





``` python
random_list = [1,2,3]

num = random_list[:3]
N = len(num)

for i in range(1<<N):
    print(i)
    empty = []   
    for j in range(N+1): 
        print(j) 
        if i & (1<<j):
            print('na')
            empty.append(num[j])
    print(empty)
```

 간단한 예시 하나를 동봉함. i 값과 j값과 두개가 같으면  na를 출력하는걸 볼수있는데

.... 일단 돌려봐