# 하나의 문제, 여러가지 알고리즘 

## 선형탐색과 이진탐색

- 선형탐색 알고리즘(Linear Search Algorithm)
- 이진탐색(Binary Search Algorithm)

## 실습 - 선형탐색 구현해보기 

> '선형 탐색(Linear Search)' 알고리즘을 사용해서 어떤 원소가 리스트 안에 포함되어 있는지 확인하려고 합니다. 선형 탐색이란, 리스트의 처음부터 끝까지 순서대로 하나씩 탐색을 진행하는 알고리즘입니다.
>
> 
>
> 파라미터로 탐색할 값 `element`와 리스트 `some_list`를 받는 함수 `linear_search`를 작성하세요. 0번 인덱스부터 순서대로 하나씩 확인해서 만약 `element`를 `some_list`에서 발견할 시 그 위치(인덱스)를 리턴해 주면 됩니다.
>
> 
>
> `element`가 `some_list`에 존재하지 않는 값이면 `None`을 리턴해주세요.

```python
def linear_search(element, some_list):
    # 코드를 작성하세요.

print(linear_search(2, [2, 3, 5, 7, 11]))
print(linear_search(0, [2, 3, 5, 7, 11]))
print(linear_search(5, [2, 3, 5, 7, 11]))
print(linear_search(3, [2, 3, 5, 7, 11]))
print(linear_search(11, [2, 3, 5, 7, 11]))
```

```python
0
None
2
1
4
```

> - 주의 사항
>
> `element in some_list`와 같이 `in` 키워드를 사용하는 건 안 됩니다. 선형 탐색에 대한 이해를 테스트하는 과제이기 때문에, 반드시 반복문을 사용해서 해결해 주셔야 합니다.

```python
def linear_search(element, some_list):
    for i in range(len(some_list)):
        if some_list[i] == element:
            return i
    return None

print(linear_search(2, [2, 3, 5, 7, 11]))
print(linear_search(0, [2, 3, 5, 7, 11]))
print(linear_search(5, [2, 3, 5, 7, 11]))
print(linear_search(3, [2, 3, 5, 7, 11]))
print(linear_search(11, [2, 3, 5, 7, 11]))
```



## 실습 - 이진탐색 구현해보기 

> ‘이진 탐색(Binary Search)’ 알고리즘을 사용해서 어떤 원소가 리스트 안에 포함되어 있는지 확인하려고 합니다. 이진 탐색 알고리즘은 선형 탐색 알고리즘과 달리, 정렬된 리스트를 전제로 합니다. 정렬된 리스트가 아니면 이 알고리즘은 적용이 불가능합니다.
>
> 
>
> 왜 이 알고리즘의 이름이 ‘이진 탐색’일까요? 1회 비교를 거칠 때마다 탐색 범위가 (대략) 절반으로 줄어들기 때문입니다.

> - 예시
>
> 예를 들어 `[1, 2, 3, 5, 8, 13, 21, 34, 55]`에서 `3`을 찾는 경우, 알고리즘의 진행 방식은 다음과 같습니다:
>
> 
>
> ### 시도 1
>
> 
>
> 리스트의 첫 번째 인덱스와 마지막 인덱스의 값을 합하여 2로 나눈 후, 중간 인덱스로 지정합니다. 그리고 그 인덱스에 해당하는 값이 `3`인지 확인해봅니다.
>
> 
>
> 이 경우 리스트의 첫 번째 인덱스는 0이고 마지막 인덱스는 8이기 때문에, 중간 인덱스는 4이고 해당 원소는 `8`입니다. 찾고자 하는 원소(`3`)는 중간 원소(`8`)에 비해 작습니다. 리스트는 정렬되어 있으니, 이제 인덱스 4~8은 탐색 범위에서 제외시킬 수 있습니다. 탐색 범위가 절반으로 줄어든 것이죠.
>
> 
>
> ### 시도 2
>
> 
>
> 탐색 범위는 이제 인덱스 0~3입니다. 탐색 범위의 첫 번째 인덱스는 0이고 마지막 인덱스는 3이기 때문에, 중간 인덱스는 `(0 + 3) // 2`인 1입니다. 인덱스 1에 해당하는 원소는 `2`이죠.
>
> 
>
> 찾고자 하는 원소(`3`)는 중간 원소(`2`)에 비해 큽니다. 리스트는 정렬되어 있으니, 이제 인덱스 0~1은 탐색 범위에서 제외시키면 됩니다. 탐색 범위가 다시 절반으로 줄어든 것이죠.
>
> 
>
> ### 시도 3
>
> 
>
> 탐색 범위는 이제 인덱스 2~3입니다. 탐색 범위의 리스트의 첫 번째 인덱스는 2이고 마지막 인덱스는 3이므로, 중간 인덱스는 `(2 + 3) // 2`인 2입니다. 인덱스 2에 해당하는 원소의 값은 `3`이죠.
>
> 
>
> 찾고자 하는 원소(`3`)는 중간에 해당하는 원소(`3`)와 일치합니다. 값을 찾았으니, 인덱스 2를 리턴해주며, 알고리즘을 종료합니다.

```python
def binary_search(element, some_list):
    # 코드를 작성하세요.

print(binary_search(2, [2, 3, 5, 7, 11]))
print(binary_search(0, [2, 3, 5, 7, 11]))
print(binary_search(5, [2, 3, 5, 7, 11]))
print(binary_search(3, [2, 3, 5, 7, 11]))
print(binary_search(11, [2, 3, 5, 7, 11]))
```

```python
0
None
2
1
4
```



## 탐색 알고리즘 비교

## 선택정렬

## 삽입정렬

## 정렬 알고리즘 비교 



